name: Auto Version on bugfix PR Merge

on:
  pull_request:
    types: [closed]
    branches: [main, master]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  # Job para garantir que PR tem labels corretos antes do merge
  ensure-labels:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    outputs:
      has_bug_label: ${{ steps.check_labels.outputs.has_bug_label }}
      
    steps:
      - name: Check and add labels if needed
        id: check_labels
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const title = context.payload.pull_request.title.toLowerCase();
            
            // Buscar labels atuais
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const currentLabelNames = currentLabels.map(label => label.name.toLowerCase());
            
            // Verificar se j√° tem labels de bug
            const bugLabels = ['urgent', 'bug', 'bugfix', 'hotfix'];
            let hasBugLabel = bugLabels.some(label => currentLabelNames.includes(label));
            
            // Se n√£o tem label mas o t√≠tulo sugere que √© um fix
            const fixPatterns = [
              /^fix:/i,
              /^fix\(/i,
              /^bugfix:/i,
              /^hotfix:/i,
              /fix.*bug/i,
              /urgent/i,
              /critical/i
            ];
            
            const titleSuggestsBug = fixPatterns.some(pattern => pattern.test(title));
            
            if (!hasBugLabel && titleSuggestsBug) {
              console.log('Title suggests this is a bug fix, adding appropriate label');
              
              // Determinar qual label adicionar baseado no t√≠tulo
              let labelToAdd = 'bug';
              if (/hotfix/i.test(title)) labelToAdd = 'hotfix';
              if (/urgent|critical/i.test(title)) labelToAdd = 'urgent';
              
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: [labelToAdd]
                });
                
                hasBugLabel = true;
                console.log(`Added label: ${labelToAdd}`);
                
              } catch (error) {
                console.error('Error adding label:', error);
              }
            }
            
            // Definir output
            core.setOutput('has_bug_label', hasBugLabel.toString());
            
            return {
              hasBugLabel,
              titleSuggestsBug,
              currentLabels: currentLabelNames
            };

  auto-version:
    runs-on: ubuntu-latest
    needs: ensure-labels
    
    # Executa se o PR foi merged E tem label de bug (manual ou autom√°tico)
    if: |
      github.event.pull_request.merged == true &&
      needs.ensure-labels.outputs.has_bug_label == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git (using PR author)
        shell: bash
        run: |
          # Usar autor do PR quando poss√≠vel
          if [ "${{ github.event.pull_request.user.email }}" != "" ] && [ "${{ github.event.pull_request.user.email }}" != "null" ]; then
            git config --local user.email "${{ github.event.pull_request.user.email }}"
            git config --local user.name "${{ github.event.pull_request.user.login }}"
            echo "Using PR author: ${{ github.event.pull_request.user.login }}"
          else
            git config --local user.email "${{ github.actor }}@users.noreply.github.com"
            git config --local user.name "${{ github.actor }}"
            echo "Using GitHub actor: ${{ github.actor }}"
          fi

      - name: Get latest version
        id: get_version
        shell: bash
        run: |
          git fetch --tags
          
          # Get all tags and filter semantic versions
          LATEST_TAG=""
          for tag in $(git tag -l); do
            if [[ "$tag" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              LATEST_TAG="$tag"
            fi
          done
          
          if [ -n "$LATEST_TAG" ]; then
            LATEST_TAG=$(git tag -l | grep -v "[a-zA-Z]" | sort -V | tail -1)
          fi
          
          if [ -z "$LATEST_TAG" ]; then
            echo "No previous tags found, starting with 1.0.0"
            NEW_VERSION="1.0.0"
            LATEST_TAG="none"
          else
            echo "Latest tag found: $LATEST_TAG"
            
            MAJOR=$(echo "$LATEST_TAG" | cut -d. -f1)
            MINOR=$(echo "$LATEST_TAG" | cut -d. -f2)
            PATCH=$(echo "$LATEST_TAG" | cut -d. -f3)
            
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          fi
          
          echo "New version will be: $NEW_VERSION"
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_tag=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Create new tag
        shell: bash
        run: |
          NEW_TAG="${{ steps.get_version.outputs.new_tag }}"
          echo "Creating tag: $NEW_TAG"
          git tag "$NEW_TAG"
          git push origin "$NEW_TAG"

      - name: Generate changelog
        id: generate_changelog
        shell: bash
        run: |
          LATEST_TAG="${{ steps.get_version.outputs.latest_tag }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_AUTHOR="${{ github.event.pull_request.user.login }}"
          
          if [ "$LATEST_TAG" = "none" ]; then
            CHANGES="- Initial release"
          else
            # Incluir o pr√≥prio PR no changelog
            CHANGES="- $PR_TITLE (#$PR_NUMBER by @$PR_AUTHOR)"
            
            # Adicionar outros commits se houver
            OTHER_CHANGES=$(git log "$LATEST_TAG"..HEAD --oneline --no-merges --grep="#$PR_NUMBER" --invert-grep | head -5 | sed 's/^/- /')
            if [ -n "$OTHER_CHANGES" ]; then
              CHANGES="$CHANGES"$'\n'"$OTHER_CHANGES"
            fi
          fi
          
          {
            echo "changes<<EOF"
            echo "$CHANGES"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        shell: bash
        run: |
          NEW_VERSION="${{ steps.get_version.outputs.new_version }}"
          CHANGES="${{ steps.generate_changelog.outputs.changes }}"
          LATEST_TAG="${{ steps.get_version.outputs.latest_tag }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          
          RELEASE_NOTES="## $NEW_VERSION
          
          ### üö® Emergency Release
          
          **Trigger:** $PR_TITLE
          
          $CHANGES"
          
          if [ "$LATEST_TAG" != "none" ]; then
            RELEASE_NOTES="$RELEASE_NOTES
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$LATEST_TAG...$NEW_VERSION"
          fi
          
          gh release create "$NEW_VERSION" \
            --title "üö® $NEW_VERSION - Emergency Release" \
            --notes "$RELEASE_NOTES"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update package.json version
        shell: bash
        run: |
          if [ -f "package.json" ]; then
            VERSION="${{ steps.get_version.outputs.new_version }}"
            echo "Updating package.json to version $VERSION"
            
            npm version "$VERSION" --no-git-tag-version --allow-same-version
            
            git add package.json
            if [ -f "package-lock.json" ]; then
              git add package-lock.json
            fi
            
            if git diff --staged --quiet; then
              echo "No changes to commit"
            else
              git commit -m "chore: bump version to $VERSION [skip ci]"
              git push origin main
            fi
          else
            echo "No package.json found, skipping version update"
          fi

      - name: Summary
        shell: bash
        run: |
          NEW_VERSION="${{ steps.get_version.outputs.new_version }}"
          LATEST_TAG="${{ steps.get_version.outputs.latest_tag }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          
          {
            echo "## üö® Emergency Release Created!"
            echo ""
            echo "**Version:** $NEW_VERSION"
            echo "**Previous:** $LATEST_TAG"
            echo "**Trigger:** $PR_TITLE"
            echo "**Author:** ${{ github.event.pull_request.user.login }}"
            echo ""
            echo "### What happened:"
            echo "- PR was automatically detected as a bug fix based on title/labels"
            echo "- Emergency release was created automatically"
            echo "- Version was bumped and released"
          } >> $GITHUB_STEP_SUMMARY
